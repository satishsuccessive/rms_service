"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Role_1 = require("../model/Role");
const UserRole_1 = require("../model/UserRole");
require("isomorphic-fetch");
class TypeLevel {
    constructor(type, level) {
        this.type = type;
        this.level = level;
    }
}
class AuthorizationManager {
    static getInstance() {
        if (!AuthorizationManager.instance) {
            AuthorizationManager.instance = new AuthorizationManager();
            AuthorizationManager.rolesGetter = AuthorizationManager.remoteRolesGetter;
            AuthorizationManager.userRolesGetter = AuthorizationManager.remoteUserRolesGetter;
        }
        return AuthorizationManager.instance;
    }
    init(config) {
        AuthorizationManager.config = config;
    }
    sanitizeMethods(rawMethods) {
        if (rawMethods) {
            const methods = rawMethods.map(rawMethod => rawMethod.toUpperCase());
            return methods;
        }
        else {
            return [];
        }
    }
    static checkExadecimal(id) {
        const idPattern = /^(?=[a-f\d]{24}$)(\d+[a-f]|[a-f]+\d)/i;
        return idPattern.test(id);
    }
    static getParentRoleId(childRoleConstraints, allRoles) {
        let childRole = null;
        if (childRoleConstraints instanceof TypeLevel) {
            const childRoles = allRoles.filter((role) => role.type === childRoleConstraints.type && role.level === childRoleConstraints.level);
            if (childRoles && childRoles.length > 0) {
                childRole = childRoles[0];
            }
        }
        else if (typeof childRoleConstraints === "string") {
            const childRoles = allRoles.filter((role) => role._id.toString() === childRoleConstraints); //toString is necessary for external role providers, as they might come straight from the database, and therefore with a different type
            if (childRoles && childRoles.length > 0) {
                childRole = childRoles[0];
            }
        }
        if (childRole) {
            return childRole.parent;
        }
        else {
            const message = "Role specified in parent clause is not valid";
            console.log(message);
            throw { message };
        }
    }
    static userIsAtLeastForApplication(requiredRoleConstraints, allRoles, userRoles, applicationId) {
        let requiredRole = null;
        if (requiredRoleConstraints instanceof TypeLevel) {
            const requiredRoles = allRoles.filter((role) => role.type === requiredRoleConstraints.type && role.level === requiredRoleConstraints.level);
            if (requiredRoles && requiredRoles.length > 0) {
                requiredRole = requiredRoles[0];
            }
        }
        else if (typeof requiredRoleConstraints === "string") {
            const requiredRoles = allRoles.filter((role) => role._id === requiredRoleConstraints);
            if (requiredRoles && requiredRoles.length > 0) {
                requiredRole = requiredRoles[0];
            }
        }
        if (requiredRole) { //requiredRole is valid
            const appUserRoles = userRoles.filter(userRole => userRole.applicationId === applicationId);
            if (appUserRoles && appUserRoles.length > 0) { //user has valid user roles for application
                for (let i = 0; i < appUserRoles.length; i++) {
                    const role = UserRole_1.default.extractRole(appUserRoles[i]);
                    if (requiredRole.descendsFrom(role, allRoles)) { //TODO: prevent loops of parents!!!!!
                        return true;
                    }
                }
            }
            else {
                return false; //user does not have any valid roles for application
            }
        }
        return false; //no user role satisfied the condition
    }
    static userIsAtLeast(requiredRoleConstraints, allRoles, userRoles) {
        return AuthorizationManager.userIsAtLeastForApplication(requiredRoleConstraints, allRoles, userRoles, AuthorizationManager.config.application);
    }
    static extractRoleIdFromUserRole(userRoleId, userRoles) {
        if (userRoles && userRoles.length > 0) {
            for (let i = 0; i < userRoles.length; i++) {
                if (userRoles[i]._id === userRoleId) {
                    return userRoles[i].roleId;
                }
            }
            const message = "Bad user role";
            console.log(message);
            throw { message };
        }
        else {
            const message = "Bad user role";
            console.log(message);
            throw { message };
        }
    }
    static extractApplicationIdFromUserRole(userRoleId, userRoles) {
        if (userRoles && userRoles.length > 0) {
            //	return userRoles[0].applicationId;
            // Working with all applications and will return the applicationId for matched userRole
            for (let i = 0; i < userRoles.length; i++) {
                if (userRoles[i]._id === userRoleId) {
                    return userRoles[i].applicationId;
                }
            }
            const message = "Bad user role";
            console.log(message);
            throw { message };
        }
        else {
            const message = "Bad user role";
            console.log(message);
            throw { message };
        }
    }
    static remoteRolesGetter(options) {
        const url = AuthorizationManager.config.allRolesEndpoint;
        const accessToken = options.accessToken;
        return fetch(url, {
            headers: {
                Authorization: accessToken
            }
        }).then(response => {
            return response.json().then((rawData) => {
                const formattedData = rawData.data.map((rawRole) => {
                    return new Role_1.default(rawRole);
                });
                return formattedData;
            });
        });
    }
    static remoteUserRolesGetter(options) {
        const endpoint = AuthorizationManager.config.authorizationEndpoint;
        let url = options.id ? `${endpoint}?/${options.id}` : `${endpoint}?`;
        if (!options.id) {
            if (options.userId)
                url += `userId=${options.userId}&`; //checking one by one to prevent bad parameters injection
            if (options.roleLevel)
                url += `roleLevel=${options.roleLevel}&`;
            if (options.roleType)
                url += `roleType=${options.roleType}&`;
            if (options.roleCode)
                url += `roleCode=${options.roleCode}&`;
            if (options.applicationId && !AuthorizationManager.config.openDomain)
                url += `applicationId=${options.applicationId}&`;
            if (options.ids && options.ids.length > 0) {
                url += "ids=";
                options.ids.forEach((id) => {
                    url += `${id},`;
                });
            }
            url = url.substr(0, url.length - 1);
        }
        return fetch(url, {
            headers: {
                Authorization: options.accessToken
            }
        }).then(response => {
            return response.json().then((rawData) => {
                const formattedData = rawData.data.map((rawUserRole) => {
                    return new UserRole_1.default(rawUserRole);
                });
                return formattedData;
            });
        });
    }
    static findMatchingRule(path, method) {
        const pathToRegexp = require('path-to-regexp');
        const rules = AuthorizationManager.config.rules;
        let matchingRule = null;
        if (rules) {
            for (const rule of rules) {
                if (!rule.methods || rule.methods.indexOf(method) > -1) {
                    const regex = pathToRegexp(rule.route);
                    const match = regex.exec(path);
                    if (match) {
                        matchingRule = rule;
                        break;
                    }
                }
            }
        }
        return matchingRule;
    }
    static extractUserRolesToLookup(ids, params, condition) {
        let userRoleIds = [];
        const applicationPattern = /extractApplication\((.*?)\)/g;
        const rolePattern = /extractRole\((.*?)\)/g;
        const applicationMatching = condition.match(applicationPattern);
        const roleMatching = condition.match(rolePattern);
        if (applicationMatching) {
            applicationMatching.forEach(match => {
                const placeholder = match.substring("extractApplication(".length, match.length - 1);
                const userRoleId = eval(placeholder);
                if (userRoleId && userRoleIds.indexOf(userRoleId) == -1)
                    userRoleIds.push(userRoleId);
            });
        }
        if (roleMatching) {
            roleMatching.forEach(match => {
                const placeholder = match.substring("extractRole(".length, match.length - 1);
                const userRoleId = eval(placeholder);
                if (userRoleId && userRoleIds.indexOf(userRoleId) == -1)
                    userRoleIds.push(userRoleId);
            });
        }
        return userRoleIds;
    }
    static lookupUserRolesInCondition(ids, params, condition, accessToken) {
        const ids2look = AuthorizationManager.extractUserRolesToLookup(ids, params, condition);
        if (ids2look && ids2look.length > 0) {
            return AuthorizationManager.userRolesGetter({ ids2look, accessToken });
        }
        else {
            return new Promise((resolve) => { resolve([]); });
            ;
        }
    }
    static extractIdsFromPath(path, route) {
        const metaTokens = route.split("/");
        const tokens = path.split("/");
        const ids = {};
        metaTokens.forEach(metaToken => {
            if (metaToken.startsWith(":")) {
                const idName = metaToken.substr(1);
                const idValue = tokens[metaTokens.indexOf(metaToken)];
                ids[idName] = idValue;
            }
        });
        return ids;
    }
    authorize(req, res, myUserRoles) {
        const accessToken = req.header("Authorization");
        return AuthorizationManager.rolesGetter({ accessToken }).then((allRoles) => {
            const path = req.baseUrl + req.path;
            const method = req.method.toUpperCase();
            const rule = AuthorizationManager.findMatchingRule(path, method);
            if (rule) {
                res.locals.ruleDescription = rule.description;
                //const id = path.split("/")[path.split("/").length-2];	//DEPRECATED!!!!!!!
                const ids = AuthorizationManager.extractIdsFromPath(path, rule.route);
                const params = Object.assign(Object.assign(req.params, req.query), req.body);
                return AuthorizationManager.lookupUserRolesInCondition(ids, params, rule.allow, accessToken).then(userRolesLookups => {
                    const parent = (roleParm1, roleParm2) => {
                        const requiredRoleConstraints = roleParm2 ? new TypeLevel(roleParm1, roleParm2) : roleParm1;
                        return AuthorizationManager.getParentRoleId(requiredRoleConstraints, allRoles);
                    };
                    const atLeast = (roleParm1, roleParm2) => {
                        const requiredRoleConstraints = roleParm2 ? new TypeLevel(roleParm1, roleParm2) : roleParm1;
                        return AuthorizationManager.userIsAtLeast(requiredRoleConstraints, allRoles, myUserRoles);
                    };
                    const atLeastForApplication = (roleParm1, roleParm2, roleParm3) => {
                        const requiredRoleConstraints = roleParm3 ? new TypeLevel(roleParm1, roleParm2) : roleParm1;
                        const applicationId = roleParm3 ? roleParm3 : roleParm2;
                        return AuthorizationManager.userIsAtLeastForApplication(requiredRoleConstraints, allRoles, myUserRoles, applicationId);
                    };
                    const extractRole = (parm1) => {
                        return AuthorizationManager.extractRoleIdFromUserRole(parm1, userRolesLookups);
                    };
                    const extractApplication = (parm1) => {
                        return AuthorizationManager.extractApplicationIdFromUserRole(parm1, userRolesLookups);
                    };
                    let isAllowed = false;
                    for (let j = 0; j < myUserRoles.length && !isAllowed; j++) {
                        const userRole = myUserRoles[j];
                        const role = UserRole_1.default.extractRole(userRole);
                        const roleLevel = role.level;
                        const roleType = role.type;
                        const roleCode = role.code;
                        const targetId = userRole.targetId;
                        const applicationId = userRole.applicationId;
                        if (eval(rule.allow)) {
                            isAllowed = true; //matching rule
                        }
                    }
                    return isAllowed;
                });
            }
            const defaultBehaviour = AuthorizationManager.config.allowWhenNoRule ? true : false;
            return defaultBehaviour;
        });
    }
}
exports.default = AuthorizationManager;
//# sourceMappingURL=AuthorizationManager.js.map